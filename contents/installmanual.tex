\chapter{Installazione del software}
%\markboth{Introduzione}{Introduzione}
\label{cap:installazione}

Il software realizzato è stato sviluppato per un sistema Linux. Le istruzioni seguenti si riferiscono principalmente alla distribuzione Ubuntu (in particolare, sono state testate con la versione 12.04) in quanto è l'unica supportata da ROS. Il software è stato testato anche con Debian: l'unica differenza risiede nell'installazione di ROS, che va fatta manualmente.

\section{Installazione del software lato PC}
\paragraph{Installazione di ROS} Le istruzioni di installazione di ROS sono presenti nel sito ufficiale, \url{www.ros.org}, e variano a seconda della distribuzione. In particolare, per Ubuntu, è necessario aggiungere i repository di ROS alle sorgenti software di sistema, dopodiché è possibile installare ROS direttamente dal package manager di Ubuntu. 

\begin{nota} I comandi per installare ROS su Ubuntu, riferiti all'ultima versione di ROS (\verb|fuerte|) e del sistema operativo (\verb|precise|) disponibile al momento della scrittura della documentazione, sono:
\begin{verbatim}
$ sudo sh -c `
    echo "deb http://packages.ros.org/ros/ubuntu precise main" 
    > /etc/apt/sources.list.d/ros-latest.list `
$ wget http://packages.ros.org/ros.key -O - | sudo apt-key add -
$ sudo apt-get update
$ sudo apt-get install ros-fuerte-desktop
\end{verbatim}
Una volta installati i pacchetti, è necessario fare in modo che le variabili di ambiente di ROS vengano impostate all'avvio:
\begin{verbatim}
$ echo "source /opt/ros/fuerte/setup.bash" >> ~/.bashrc
$ . ~/.bashrc
\end{verbatim}
Da ultimo, è necessario installare alcuni componenti aggiuntivi di ROS che verranno utilizzati in seguito:
\begin{verbatim}
$ sudo easy_install -U rosinstall vcstools rosdep
\end{verbatim}
\end{nota}

\paragraph{Installazione delle dipendenze} Per poter compilare correttamente il software realizzato, è necessario che siano presenti sul sistema, oltre a ROS, i seguenti pacchetti installabili dai repository della distribuzione Linux in uso:
\begin{itemize}
\item \verb|flex| e \verb|bison|, utilizzate per generare i parser di Mr. Brian
\item le librerie OpenCV (\verb|libopencv-dev|), utilizzate per elaborare le immagini in Vision e in LittleEndian
\item le librerie Qt4\footnote{Probabilmente le librerie Qt sono già installate da ROS come dipendenza} (\verb|libqt4-dev|), utilizzate per l'interfaccia grafica
\item le librerie Qt Mobility (\verb|qtmobility-dev|), che contengono QtMultimediaKit, utilizzato per la riproduzione dei suoni
\end{itemize}

È inoltre necessario installare il pacchetto di ROS \verb|ann|\footnote{\url{http://ros.org/wiki/ann}}, contenuto nello stack \texttt{ias\_perception}. Attualmente (marzo 2013), questo stack non è più disponibili sul sito di ROS (sono stati deprecati). Ann è parte del package "ias-perception", che si può scaricare dal repository git seguente:
\url{http://code.in.tum.de/git/ias-perception.git}, accessibile anche dall'interfaccia web che si trova al link \url{http://code.in.tum.de/indefero/index.php//p/ias-perception/source/tree/master/}. Una volta scaricato è sufficiente compilarlo con il comando \verb|make| sia dalla cartella principale \verb|ias-perception| che dalla sottocartella \verb|ann|, e successivamente copiarlo in una cartella presente nel PATH degli stack di ROS (ad esempio \verb|/opt/ros/fuerte/stacks|).

\paragraph{Compilazione del software} Innanzitutto, scaricare i sorgenti da git:
\begin{verbatim}
$ git clone git://github.com/pogliamarci/robotower.git
\end{verbatim}
oppure dalla pagina del progetto sull'airwiki in una cartella qualunque. Una volta scaricati i file, è necessario aggiungere la cartella del progetto alla variabile d'ambiente \verb|ROS_PACKAGE_PATH|, inserendo in fondo al file \verb|~/.bashrc| la riga
\begin{verbatim}
export ROS_PACKAGE_PATH=path:$ROS_PACKAGE_PATH
\end{verbatim}
dove \verb|path| va sostituito con il percorso completo della cartella che contiene i sorgenti del progetto. Dopo aver aggiornato il file \verb|~/.bashrc|, eseguire
\begin{verbatim}
$ source ~/.bashrc
\end{verbatim}
A questo punto, dovrebbe essere possibile compilare i sorgenti eseguendo semplicemente
\begin{verbatim}
$ make
\end{verbatim}
dalla cartella principale del progetto.

\begin{nota}
In alternativa, è possibile utilizzare il comando \verb|rosmake <nome_package>| per ognuno dei package realizzati. Quest'ultimo comando dovrebbe tentare di compilare e/o risolvere automaticamente le dipendenze, ma in generale risulta più lento e fornisce meno indicazioni sullo standard output rispetto all'utilizzo di \verb|make|.
\end{nota}

\section{Avvio del gioco} Una volta collegato al computer lo XBee e acceso il robot, collegarsi alla rete wireless creata da Spykee\footnote{il SSID è SPYKEE seguito da un codice identificativo del robot. Non è necessario inserire manualmente i parametri della connessione (indirizzo IP, ...), in quanto il robot funziona da server DHCP}. A questo punto, per avviare ROS e tutti i nodi che controllano il robot, è sufficiente eseguire il comando
\begin{verbatim}
$ roslaunch spykee.launch
\end{verbatim}
dalla cartella del progetto.

\begin{nota}
Se il nodo Echoes non riesce ad accedere alla porta seriale, è possibile che i permessi per l'utente corrente non consentano di aprire il dispositivo: per risolvere questo problema è sufficiente aggiungere l'utente corrente al gruppo \verb|dialout| oppure impostare i permessi corretti tramite regole di \verb|udev|.
\end{nota}

\section{Firmware del microcontrollore}

Il firmware è stato realizzato per la scheda (Evaluation Board) STM32F4 Discovery della ST. Nelle istruzioni che seguono, verrà utilizzato il programmatore integrato sulla scheda (ST-Link v2).

\subsection*{Prerequisiti}
\begin{enumerate}
\item Installare una toolchain GNU per ARM. Per la realizzazione del firmware, è stata utilizzata  CodeSourceryLite\footnote{scaricabile da \url{http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/}}, che fornisce una versione precompilata della toolchain GNU (gcc, gdb, ...). È sufficiente scaricare l'archivio, decomprimerlo in una cartella, e aggiungere la sottocartella \verb|bin| dell'archivio nel \verb|PATH| dell’utente. Una volta che la toolchain è installata, il compilatore è raggiungibile dal comando 
\begin{verbatim}
$ arm-none-eabi-gcc
\end{verbatim}
Se si usa una toolchain diversa, potrebbe essere necessario cambiare i nomi degli eseguibili nel \verb|Makefile|.

\begin{nota}
Attualmente CodeSourceryLite viene rilasciato compilato per processori x86 a 32bit. Nel caso il sistema operativo in uso sia a 64 bit, è necessario installare le librerie \verb|ia32-libs|.
\end{nota}

\item Installare OpenOCD, scaricabile da \url{http://openocd.sourceforge.net}. Potrebbe essere necessario installare alcune dipendenze (autotools, automake, libusb ed altre), elencate comunque nella documentazione del programma.

\begin{nota}
Al momento della scrittura del presente manuale (luglio 2012), il programmatore ST-Link v2 è ufficialmente supportato solo sulla piattaforma Windows. Tuttavia, è presente un supporto sperimentale in OpenOCD: per poterlo utilizzare, è necessario scaricare e compilare la release di sviluppo dal repository git\footnote{\url{http://sourceforge.net/scm/?type=git&group_id=274635}}. Una volta scaricati i sorgenti, è sufficiente compilarli tramite i seguenti comandi  (dalla cartella in cui si è clonato il repository):
\begin{verbatim}
$ ./configure --enable-maintainer-mode --enable-stlink
$ make
# make install
\end{verbatim}
L'ultimo comando serve per installare OpenOCD nelle cartelle di sistema e configurare alcune regole di udev: dev'essere quindi eseguito con i privilegi di root.
\end{nota}

\item Scaricare i sorgenti di ChibiOS da \url{http://chibios.org}. Una volta scaricato e decompresso l'archivio, aprire il \verb|Makefile| presente nella cartella \verb|FirmwareSpykee| e modificare la riga
\begin{verbatim}
CHIBIOS = /opt/ChibiOS/ChibiOS_2.4.2
\end{verbatim}
inserendo il percorso corretto. Il firmware è stato testato con la versione 2.4.2 di ChibiOS.
\end{enumerate}

\subsection*{Compilazione ed installazione}

\paragraph{Compilazione} Posizionarsi nella cartella \verb|FirmwareSpykee| ed eseguire
\begin{verbatim}
$ make
\end{verbatim}
Se la compilazione ha successo, viene creato nella sottocartella \verb|build| il file \verb|ch.elf|.

\paragraph{Installazione} Per caricare il firmware sulla scheda, è necessario prima di tutto spegnere l'alimentazione\footnote{Attenzione! Collegare l'alimentazione della scheda quando è collegata al computer tramite USB potrebbe causare seri danni alla stessa e renderla inutilizzabile} (tramite l'apposito interruttore) e collegare la scheda al computer tramite USB. Si deve quindi avviare OpenOCD con il comando
\begin{verbatim}
$ openocd -f board/stm32f4discovery.cfg
\end{verbatim}
Quindi, mantenendo aperto OpenOCD, collegare il debugger gdb:
\begin{verbatim}
$ arm-none-eabi-gdb ch.elf
(gdb) target extended-remote localhost:3333
\end{verbatim}
dove \verb|ch.elf| è il percorso del firmware compilato che si vuole caricare sulla scheda. Una volta che \verb|gdb| è connesso ad OpenOCD, la seguente sequenza di comandi cancella il contenuto della memoria FLASH, carica il nuovo firmware, e quindi lo avvia:
\begin{verbatim}
(gdb) monitor reset halt
(gdb) monitor flash probe 0 
(gdb) monitor stm32f2x mass_erase 0 
(gdb) load 
(gdb) monitor reset halt 
(gdb) continue
\end{verbatim}

\begin{nota} A volte la scheda non viene riconosciuta da OpenOCD. Questo problema a volte viene risolto tenendo premuto il pulsante RESET sulla scheda mentre si avvia openOCD. Se anche così non funziona, è necessario cancellare il contenuto della memoria flash con l'utility ST Visual Programmer (disponibile solo per Windows).
\end{nota}

\section{Collegamenti hardware}
Attualmente, i pin presenti sulla Discovery Board montata sul robot sono assegnati in questo modo:
\begin{itemize}
\item Collegamento con i sonar (timer): \verb|PA8| (nord), \verb|PB4| (sud), \verb|PA0| (ovest), \verb|PC6| (est)
\item Seriale per collegamento con lo XBee, bitrate 115200 bps: \verb|PA2| (TX, va collegato al terminale \verb|RX| dello XBee) e \verb|PA3| (RX, va collegato al terminale \verb|TX| dello XBee)
\item Ricevitore dei segnali inviati
	\begin{itemize}
	\item Dalle fabbriche: \verb|PD0|, \verb|PD1| e \verb|PD2|
	\item Dalla torre: \verb|PD3|
	\end{itemize}
\item Led presenti sul robot:
	\begin{itemize}
	\item Led rossi: \verb|PE7| (0), \verb|PE8| (1), \verb|PE9| (2), \verb|PE10| (3)
	\item Led gialli: \verb|PE11| (0), \verb|PE12| (1), \verb|PE13| (3), \verb|PE14| (4)
	\item Led verde: \verb|PE15|
	\item Led a infrarossi (sulle spalle del robot): \verb|PD11|
	\end{itemize}
\item Lettore RFID (collegamento seriale a 9600 bps): \verb|PB11| (RX)
\end{itemize}
\begin{nota}
Il file \verb|board.h| permette di configurare le funzioni assegnate ai vari pin (input, output, alternate mode), secondo le informazioni presenti sul datasheet. Per modificare l'assegnamento dei pin, potrebb eessere necessario modificare - oltre a \verb|board.h| - il sorgente dei moduli del firmware che ne fanno uso.
\end{nota}

\paragraph{Alimentazione} Tutti i dispositivi (discovery board, XBee, lettore RFID, sonar, ricevitore Atmel, driver per i led a infrarossi) vanno alimentati a $+5$V DC tramite il regolatore di tensione collegato alla batteria principale di Spykee. La scheda contenente le resistenze necessarie al funzionamento dei led necessita soltanto del collegamento a massa.

\paragraph{Configurazione Zigbee} I dispositivi Xbee vengono utilizzati come un collegamento seriale punto-punto tra l'unità di elaborazione e il robot, pertanto per il debugging di problemi di configurazione è sufficiente utilizzare un terminale seriale, come \verb|screen| o \verb|minicom| su Linux. Per configurare i dispositivi Xbee è necessario utilizzare il programma X-CTU scaricabile dal sito Digi. Una volta aperta la scheda di configurazione, è sufficiente impostare su entrambi i dispositivi il bitrate di $115200$ bps, e impostare come Destination Address (High e Low) il Serial Number dell'altro Xbee.

\section{Comandi per il firmware del robot}
Il firmware installato sulla discovery board presente nel robot accetta alcuni comandi che vengono inviati dal nodo \verb|Echoes| attraverso il collegamento seriale, e permettono di controllare i led:
\begin{itemize}
\item \verb|reset|: spegne tutti i led
\item \verb|led|: comanda i led colorati. Il comando è seguito da \verb|R|, \verb|Y| oppure \verb|G| a seconda che si vogliano comandare rispettivamente i led rossi, i led gialli oppure il led verde che c'è sulla testa di Spykee. Il secondo argomento del comando può essere \verb|B| per attivare la modalità lampeggiante del gruppo di led selezionato, oppure una stringa di cifre binarie che indicano se ognuno dei led del gruppo deve essere spento (\verb|0|) oppure acceso (\verb|1|). Ad esempio, il comando
\begin{verbatim}
    led R 1101
\end{verbatim}
accende il primo, il secondo e l'ultimo dei led rossi e spegne il terzo, mentre il comando
\begin{verbatim}
    led G B
\end{verbatim}
fa lampeggiare il led verde sulla testa del robot.
\item \verb|infrared on| accende i led a infrarossi, mentre \verb|infrared off| li spegne.
\end{itemize}

I messaggi inviati dal robot al computer attraverso il collegamento seriale sono composti da una singola linea (sono terminati da \verb|CR LF|) e contengono all'inizio la tipologia tra parentesi quadre. Le tipologie di messaggio che sono state definite, insieme con un esempio del loro formato, sono:
\begin{itemize}
\item \verb|[SONAR] N:1443,S:161,W:3444,E:3458| contiene per i quattro sonar installati (nord, sud, ovest, est) la distanza rilevata in millimetri
\item \verb|[RFID] <id>| contiene l'ID del tag RFID rilevato. Contiene anche il checksum, calcolato come da datasheet del lettore ID-12 (la correttezza viene calcolata da Echoes e non a bordo del firmware).
\item \verb|[TOWER] destroyed <N>| indica che una torre o fabbrica è stata distrutta. \verb|<N>| è compreso tra $1$ e $4$ e identifica la torre o la fabbrica che è stata distrutta.
\end{itemize}